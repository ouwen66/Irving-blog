---
title: Java位运算
tags:
  - Java
  - 笔记
categories: Java
cover: https://w.wallhaven.cc/full/r2/wallhaven-r2v99w.jpg
declare: true
abbrlink: f789481e
---

## 前言

日常开发中位运算不是很常用，但是巧妙的使用位运算可以大量减少运行开销，优化算法。

<!-- more -->

## 位运算符

Java支持的位运算有7种，具体如下：

- **&：按位与。**
- **|：按位或。**
- **~：按位非。**
- **^：按位异或。**
- **<<：左位移运算符。**
- **>>：右位移运算符。**
- **<<<：无符号右移运算符。**

### 1、按位与(&)

按位与的运算规则

| 操作数1     | **0** | **0** | **1** | **1** |
| ----------- | ----- | ----- | ----- | ----- |
| **操作数2** | **0** | **1** | **0** | **1** |
| **按位与**  | **0** | **0** | **0** | **1** |

**规则总结：**只有两个操作数对应位同为1时，结果为1，其余全为0（或者是只要有一个操作数为0，结果就为0）

**举例：**

![](https://gitee.com/ouwen666/my-image/raw/master/img/yu.png)

### 2、按位或(|)

按位或的运算规则

| 操作数1     | **0** | **0** | **1** | **1** |
| ----------- | ----- | ----- | ----- | ----- |
| **操作数2** | **0** | **1** | **0** | **1** |
| **按位或**  | **0** | **1** | **1** | **1** |

**规则总结：**只有两个操作数对应位同为0时，结果为0，其余全为1（或者是只要有一个操作数为1，结果就为1）

### 3、按位非(~)

按位非的运算规则

| 操作数     | 0     | 1     |
| ---------- | ----- | ----- |
| **按位或** | **1** | **0** |

**规则总结：**取反操作，在求负数的源码中使用过

### 4、按位异或(^)

按位异或的运算规则

| 操作数1      | **0** | **0** | **1** | **1** |
| ------------ | ----- | ----- | ----- | ----- |
| **操作数2**  | **0** | **1** | **0** | **1** |
| **按位异或** | **0** | **1** | **1** | **0** |

**规则总结：**只有两个操作数不相同时，结果为1，其余全为0（或者是只要两个操作数相同就为0）

### 5、左位移(<<)

**运算规则：**算术左移，溢出截断，符号位不变，低位补0。如：2<<2结果为8。

![](https://gitee.com/ouwen666/my-image/raw/master/img/zuoweiyi.png)

### 6、右位移(>>)

**运算规则：**算术右移，溢出截断，符号位不变，用符号位补高位。如：-6>>2结果为-2。

![](https://gitee.com/ouwen666/my-image/raw/master/img/youweiyi.png)

### 7、无符号右移(>>>)

**运算规则：**低位溢出，高位补0

![](https://gitee.com/ouwen666/my-image/raw/master/img/wufuhao.png)

## 常见使用

因位运算在日常开发中并不是很常用的，这里举两个例子加强理解

### 1、判断一个数n的奇偶性

```java
n&1 == 1?"奇数":"偶数"
```

为什么与1能判断奇偶？所谓的二进制就是满2进1，那么好了，偶数的最低位肯定是0（恰好满2，对不对？），同理，奇数的最低位肯定是1。int类型的1，前31位都是0，无论是1&0还是0&0结果都是0，那么有区别的就是1的最低位上的1了，若n的二进制最低位是1（奇数）与上1，结果为1，反则结果为0。

### 2、取绝对值

```java
(a^(a>>31))-(a>>31)
```

先整理一下使用位运算取绝对值的思路：若a为正数，则不变，需要用异或0保持的特点；若a为负数，则其补码为源码翻转每一位后+1，先求其源码，补码-1后再翻转每一位，此时需要使用异或1具有翻转的特点。

任何正数右移31后只剩符号位0，最终结果为0，任何负数右移31后也只剩符号位1，溢出的31位截断，空出的31位补符号位1，最终结果为-1.右移31操作可以取得任何整数的符号位。

那么综合上面的步骤，可得到公式。a>>31取得a的符号，若a为正数，a>>31等于0，a^0=a，不变；若a为负数,a>>31等于-1 ，a^-1翻转每一位。

### 3、不用临时变量交换两个数

连续三次使用异或，并没有临时变量就完成了两个数字交换，怎么实现的呢？

```
int a = 3,b = 4;
a = a^b;
b = b^a; //b=b^(a^b)-->b=a
a = a^b; //a=(a^b)^(b^(a^b))-->a=b
```

上面的计算主要遵循了一个计算公式：b^(a^b)=a。

我们可以对以上公式做如下的推导：

任何数异或本身结果为0.且有定理a^b=b^a。异或是一个无顺序的运算符，则b^a^b=b^b^a，结果为0^a。

再次列出异或的计算表:

| 操作数1      | **0** | **0** | **1** | **1** |
| ------------ | ----- | ----- | ----- | ----- |
| **操作数2**  | **0** | **1** | **0** | **1** |
| **按位异或** | **0** | **1** | **1** | **0** |

可以发现，异或0具有保持的特点，而异或1具有翻转的特点。使用这些特点可以进行取数的操作。

那么0^a，使用异或0具有保持的特点，最终结果就是a。

其实java中的异或运算法则完全遵守数学中的计算法则：

①  a ^ a =0

②  a ^ b =b ^ a

③  a ^b ^ c = a ^ (b ^ c) = (a ^ b) ^ c;

④  d = a ^b ^ c 可以推出 a = d ^ b ^ c.

⑤  a ^ b ^a = b.